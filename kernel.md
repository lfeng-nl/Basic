## 内存管理

### 1.页

-   物理页为内存管理的基本单位；通常为4K，64位机器会支持8K；
-   内核用`struct page`结构表示系统中的每个==物理页==；表示相应物理页是否使用、当前状态等信息；
-   ​

### 2.区

由于硬件限制，有些页位于内存中特定的物理地址上，所以不能将其用于特定任务，所以内核将页划分为不同的区；

-   四种内存分区：
    -   ZONE_DMA：能执行DMA操作；
    -   ZONE_DMA32：同上，只是只能被32位设备访问；
    -   ZONE_NORMAL：能正常映射的内存；
    -   ZONE_HIGHEM：高端内存，其中的页并不能永久的映射到内核地址空间。
    -   **高端内存的最基本思想**：借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。
-   页获取：`kmalloc()`：确保页在物理地址上是连续的（虚拟地址也是连续的） `vmalloc()`：只确保虚拟地址空间内是连续的，物理上可以分配不连续的块；核心函数为`alloc_pages()`

### 3.slab层

在内核中，空闲链表面临的主要问题之一是不能全局控制，当可用内存变得紧缺时，内核无法通知每个空闲链表，让其收缩缓存大小以便释放一些内存；

slab分配器，扮演了通用数据缓存层的角色；

-   在SLAB中，可分配的内存块称之为对象；slab层把==不同的对象划分为所谓的高速缓存组==，其中每个高速缓存组都存放不同类型的对象。如，一个高速缓存用于存放进程描述符，另一个高速缓存存放索引结点对象（sturct inode）;
-   ==高速缓存==又被划分为slab，（==slab由一个或多个物理上的连续页组成==，一般仅一页）；
-   ==每个slab==都包含一些对象成员（被缓存的数据结构），

>   例如`inode`结构，`struct inode`结构由`inode_cachep` 高速缓存进行分配；
>
>   `inode_cachep`高速缓存包含多个`slab`，每个`slab`包含尽可能多的`struct inode`对象，当内核请求分配新的`inode`结构体时，内核就从`slab`返回一个指向已分配但未使用的结构的指针。

-   每个高速缓存都用一个`kmem_cache`结构表示；该结构体通过`struct kmem_list3 **nodelists`包含三个链表：`slabs_full，slabs_partial,slabs_empty` ，分别表示完全分配的，部分分配的，空的或没有对象被分配；

-   `slab`描述符用结构体`struct slab`描述每个`slab` ；

    ```c
    struct slab {
    	struct list_head list; 			// slab 会连接到三个链表中的其中一个；
    	unsigned long colouroff;
        void *s_mem;		 			// slab 中的第一个对象地址
    	unsigned int inuse;				// 已分配的对象数
    	kmem_bufctl_t free;				// 第一个空闲对象
    };
    ```

### 4.伙伴算法

主要解决频繁的请求和释放不同大小的一组连续页框，导致在已分配页框内分散了许多小块的空闲页面；由此带来的问题是，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框无法满足请求；

