## 树

> [参考](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))
>
> 无环连通图

## 1.二叉树

> 每个结点最多含有两个子树的树；

- 满二叉树: 叶子节点都在最底层, 除了叶子节点, 所有节点都有两个子节点.
- **完全二叉树**: 叶子节点在最底层, 最后一层叶子节点靠左排列.
    - 可以使用数组存储.

### 1.二叉树的遍历

> 前序: 中左右
>
> 中序: 左中右,
>
> 后序: 左右中; 
>
> 遍历的目的: 数的遍历都是将树的结点变成某种意义的线性序列, 方便程序处理;
>
> 已知前序, 中序, 可以唯一确定一颗二叉树;
>
> 已知后续和中序, 可以唯一确定一棵二叉树;
>

- **先(前)序遍历**： 先访问**根结点**，**先序遍历左子树**，**先序遍历右子树**；（递归）**第一个肯定是根节点**

    ```c
    void PreOrderTraversal(BinTree BT)
    {
      if(BT){
        printf("%d\n", BT->Data);
        PreOrderTraversal(BT-Left);
        PreOrderTraversal(BT->Right);
      }
    }
    ```

- **中序遍历**： **中序**遍历左子树，访问**根结点**，**中序**遍历右子树；（递归）**根节点左右两侧分别为左子树和右子树**

    ```c
    void InOrderTraversal(BinTree BT)
    {
      if(BT){
        InOrderTraversal(BT-Left);
        printf("%d\n", BT->Data);
        InOrderTraversal(BT->Right);
      }
    }
    ```

- **后序遍历**： **后序**遍历左子树，**后序**遍历右子树，访问**根结点**；（递归）**最后一个肯定是根节点**

    ```c
    void PostOrderTraversal(BinTree BT)
    {
      if(BT){
        postOrderTraversal(BT-Left);
        postOrderTraversal(BT->Right);
        printf("%d\n", BT->Data);
      }
    }
    ```

- 层序遍历 `BFS`：

    - 队列实现：从根结点开始，将结点入队，然后执行循环{结点出队，访问该结点，左儿子入队，右儿子入队}

        ```c
        AddQ(Q, BT);						// 根结点入队
        while(!IsEmptyQ(Q)){
          T = DeleteQ(Q);					// 出队，
          printf("%d\n", T->Data);			// 访问
          if(T->Left) AddQ(Q, T->Left);		// 左结点入队
          if(T->Right) AddQ(Q, T->Right);	// 右结点入队
        }
        ```

## 2.重要树

### 1.平衡二叉树，AVL树

- 平衡的目的: 解决二叉树因为动态更新导致的退化问题.

### 2.红黑树 R-B Tree

> **搜索, 插入, 删除的时间复杂度都是O(logn)**, 1. 稳定, 2.相对AVL, 调整的代价小.
>
> 不追求过分的平衡, 从而降低了插入和删除的时间复杂度.
>
> 应用场景: Java中的HashMap, 
>
> ([清晰理解红黑树的演变---红黑的含义 - 甜菜波波 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tiancai/p/9072813.html))

- 红黑树的应用比较广泛，主要用来存储有序的数据，时间复杂度是`O(logn)`，效率很高；应用有：STL中set，map，以及Linux虚拟内存的管理；

- 红黑树的特性：

    - **根节点是黑色**；

    - 每个节点或者是黑色，或者是红色。

    - 每个**叶子节点都是是黑色的空节点（`NIL`）节点**；

    - **红色节点不相连**;

    - 从一个**节点到该节点的子孙节点的所有路径上包含相同数目的黑节点**；

        ![红黑树](https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg)

### 3.赫夫曼树

> 结点的带权路径长度: 结点到根结点之间的**路径长度**与**结点的权**的乘积;
>
> WPL, 树的带权路径长度: 所有子节点的**带权路径长度**之**和**;
>
> 赫夫曼树: WPL最小的二叉树, 也称最优二叉树; 
>
> ![WPL](D:/GitHub/Algorithm/image/wpl.PNG)
>
> $WPL = 5 \times3+15\times3+40\times2+30\times2+10\times2$



- 构造方法:
    1. 将权值最小的两个节点合并, 父节权值为二者之和;
    2. 将合并后的父节点并入原有数据列表中, 重复上述动作
- 赫夫曼树特点:
    1. 没有度为1的节点;
    2. 任意非叶节点打左右子树交换后仍是赫夫曼树;
    3. 如果赫夫曼树叶子节点的数目为n, 则总打节点数为: $2n-1$;
- 哈夫曼编码：
    - 前缀码: 任何字符的编码都不是另一字符编码打前缀;
    - 将字符出现的频率作为权值, 建立赫夫曼树, 