# 基础算法

## 1.递归和分治

> 递归: 一种编程技巧. 在函数定义中使用函数自身. 
>
> 分治: 一种处理问题的思想, 分治算法一般都比较适合用递归实现.

- 分治算法的递归实现:
    - 分解: 将原问题分解成子问题.
    - 解决: 递归求解子问题.
    - 合并: 将子问题结果合并成原问题.
- 分治算法的适用场景:
    - 原问题和分解后的小问题具有相同的模式.
    - 子问题之间没有相关性.

## 2.前缀和

> 可以理解为数列的前n项和. 预处理,  能降低后续查询的复杂度.

- `s[i] = q[i] + s[i-1]`
- 二维前缀和: `s[i][j] = q[i][j] + s[i-1][j] + s[i][j-1] - s[i-1][j-1]`

## 3.差分(前缀和的逆运算)

- `d[i] =  q[i] - q[i-1]`
- 对q的从`i到j(i<j)`加上`c`, 差分数列的变化: `d[i] + c, d[j] - c`
-  可认为原数列为全是0 的数列, 则当前差分数列为`[0, 0, ..., 0]`, 然后依次插入当前数列的值, 计算插入后的差分数列.

## 4.双指针

> 可以将多维度的暴力循环算法(O(n^2))优化到O(n)

- 先写出暴力算法, 然后在其基础上优化.

### 1.盛水最多的容器

![](./image/question_11.jpg)

- 初始时, `i`指向a[0], `j`指向a[n].
- 面积 `s = (j-i) * min(a[0], a[n])`
    - 假设`a[0] < a[n]`: 可以看出, `a[0]`与其余点的所有边的组合面积都只会小于`s`( 长度小于`j-i`, 高度小于等于 `a[0]`), 可以移除`a[0]`, 讨论其他边的组合情况.
    - 假设`a[0] = a[n]`: `a[0]`与其他所有边的组合或者`a[n]`与其他所有边的组合面积只会小于`s`, 可以排除`a[0], a[1]`, 讨论其他组合情况.

## 5.离散化

> 对于一些数值范围很大, 但是数的个数很少. 可以将值映射到排序之后的位置上. 

- 离散化的方式:

    1. 排序
    2. 去除重复元素
    3. 元素的位置和值 -- 映射关系

    - 这里, 数值离散化后的值 == 数值在有序数列中的位置. (可以使用二分计算).

## 6.贪心

> [参考](https://oi-wiki.org/basic/greedy/)
>
> 贪心算法（英文：greedy algorithm），是用计算机来模拟一个“贪心”的人做出决策的过程。每一步总是按某种指标选取最优的操作, 并不考虑以后可能造成的影响.
>
> **并不是所有的时候贪心法都能获得最优解**，所以一般使用贪心法的时候，都要确保自己**能证明其正确性**

### 1.证明方法[¶](https://oi-wiki.org/basic/greedy/#_4)

贪心算法有两种证明方法：反证法和归纳法。一般情况下，一道题只会用到其中的一种方法来证明。

1. 反证法：如果交换方案中任意两个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经是最优解了。
2. 归纳法：先算得出边界情况（例如 ）的最优解,然后再证明：对于每个 ,都可以由 推导出结果。

### 2.常见题型[¶](https://oi-wiki.org/basic/greedy/#_6)

- 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。
- 「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）

二者的区别在于第一种是离线的，先处理后选择；一种是在线的，边处理边选择。

### 3.排序解法[¶](https://oi-wiki.org/basic/greedy/#_7)

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

### 4.后悔解法[¶](https://oi-wiki.org/basic/greedy/#_8)

思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。

### 5.与动态规划的区别[¶](https://oi-wiki.org/basic/greedy/#_10)

- 贪心算法对每个子问题的解决方案都做出选择，不能回退。
- 动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 7.哈希

> MD5, SHA等

- 应用场景: 
    - 负债均衡: 根据ip或者session哈希, 分配到同一后端服务器上.
    - 大文件搜索关键词: 
        - 1.对数据进行分片. 然后采用多台机器并行处理.
        - 2.每个机器负责一批关键词的处理(**靠哈希函数分配**).
    - 分布式存储:
        - 

- 一致性哈希[参考](https://zhuanlan.zhihu.com/p/24440059):
    - 原有哈希存在的问题: **当进行扩容或者收缩时, 重新计算哈希, 原有的分配方案错乱.**
    - 一致性哈希方案: 
        - 1.预先假定. 我们有n资源点, 但实际上只有少于n个资源点.
        - 2.分配时, 先判定资源点是否存在, 不存在就向后找.
        - 3.扩容时, 新加入资源点只需要从后续点中拿出自己的资源即可.
        - 4.还可以将所有资源点作为环形.

