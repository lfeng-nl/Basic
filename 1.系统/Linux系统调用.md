# 1.概述

## 1.系统调用

- 在用户空间和硬件设备之间添加的一个中间层; 主要目的
  - 底层硬件的抽象接口;
  - 对应用程序进行权限控制;
  - 使得程序具有可移植性;

## 2.C 库和系统调用

- Linux 的系统调用作为 C 库的一部分提供, C 库实现了主要的 API;
- 对于应用编程而言, 仅适用 API 即可, 不需要直接调用系统调用;
- 系统调用通常适用负数表示错误, C 库会把错误码写入`errno`全局变量, 可以通过`perror()`库函数翻译为字符串;

# 2.系统调用实现

- 系统调用函数实现:
  - 根据参数不同, 借助`SYSCALL_DEFINEx(xxx)`的宏, 实现系统调用, 展开为`sys_xxx`;
- 系统调用号:
  - 每一个系统调用被分配一个系统调用号. 用户进程将系统调用号放入寄存器, 触发中断, 进行系统调用.
  - `sys_ni_syscall()`表示未实现系统调用, 返回`-ENOSYS`;
- 系统调用表`sys_call_table`
  - 所有注册的系统调用存储在`sys_call_table`中;
  - `sys_call_table = {[0 ... __NR_syscall_max] = &sys_ni_syscall, #include <asm/syscalls_64.h>}`, `sys_call_table` 中空余位置被初始化为未定义系统调用;
  - `syscalls_64.h`为编译生成, 内容类似`__SYSCALL_COMMON(0, sys_read, sys_read)`, 展开为`[0] = sys_read`;
- 系统调用过程:
  - 用户进程出发`0x80`中断, 并通过寄存器传入系统调用号和参数, 中断处理函数读取系统调用号, 通过`sys_call_table`查找到相应相应的函数, 调用;

# 3.系统调用的调用

- 通常, 系统调用通过C库支持, 用户程序直接调用相应的库函数.
- 也可以通过宏`_syscallx(type, name, xx, xx)`调用相应的系统调用;
  - 该宏会将参数和系统调用号(`__NR_name`, 宏定义, 对应系统调用号)放入寄存器, 出发中断, 完成系统调用;